package dstelmachenko.collections;

import org.junit.Test;

import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Map;

import static org.junit.Assert.*;

public class UserMapTest {

    private Calendar birthDate1 = new GregorianCalendar();

    /**
     * 5.5.2
     * Результат первого теста таков
     * {dstelmachenko.collections.UserMap@157fcb0=Value1, dstelmachenko.collections.UserMap@176c05c=Value2}
     * потому как ключами карты являются два разных объекта user1 и user2,
     * не смотря на то, что у них одинаковые поля, у них разные хэш-коды.
     *
     * 5.5.3
     * После того как переопределили метод hashCode, результат
     * {dstelmachenko.collections.UserMap@1f74cfa8=Value1, dstelmachenko.collections.UserMap@1f74cfa8=Value2}
     * Видим, что несмотря на одинаковые хэш-коды у двух разных объектов,
     * в коллекции не произшло замещение значения первого элемена. В коллекцию добавился второй элемент.
     * Это связано с тем, что хэш-функция может давать одинаковые значения для разных аргументов.
     * И в HashMap хранение каждого элемента организовано деревом. Если мы добавляем элемент
     * и такой хэш-код уже имеется в коллекции, и при этом объекты не равны, то добавляемый элемент записывается в дерево.
     *
     * 5.5.4
     * После того, как переопределили только equals
     * {dstelmachenko.collections.UserMap@157fcb0=Value1, dstelmachenko.collections.UserMap@176c05c=Value2}
     * У объектов разные хэш-коды и в коллекцию записывается два элемента
     *
     * 5.5.5
     * Перекрыты и hashCode и equals
     * {dstelmachenko.collections.UserMap@a1342d6=Value2}
     * Так как у нас и хэш-коды равны и объекты считаются равными друг-другу, ир добавления второго элемента не происходит,
     * меняется значение у первого элемента.
     *
     * 5.5.6
     * Коллизия (столкновение) в Map - это когда происходит попытка записи значения в ячейку по адресу которой уже есть элемент.
     * Это связано с тем, что хэш-фунции не гаранитруют уникальное значение хэша для каждого элемента. Если у объекта,
     * добавляемого в коллекцию вычисляется такой же хэш, как у объекта, который уже есть в коллекции, то происходит коллизия.
     * Разрешается она следующим образом, если объекты равны (equals), то значение элемента заменяется на новое. Если же нет,
     * то в ячейку связанным списком добавляется следующий элемент. И в ячейке хранится не один элемент коллекции,
     * а связанный список элементов. Это до восьмой версии Java. После восьмой вместо списка используются сбалансированные деревья,
     * что позволяет уменьшить временную сложность поиска элемента с линейной до логарифмической.
     *
     * 5.5.7
     * Хэш-код объекта должен равномерно зависеть от всех значений полей объекта, быть одинаковым для одинаковых
     * значений полей объекта и, по возможности, давать уникальные значения для разных объектов.
     * Лучше всего суммировать значение каждого поля умноженного на какое-нибудь простое число.
     *
     * Хэш в мапах вычислется от хэша объекта возведением в степень с битовым сдвигом
     * return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
     *
     */

    @Test
    public void testCreation() {
        birthDate1.set(1982, 2, 23);
        UserMap user1 = new UserMap("John Smith", 2, birthDate1);
        UserMap user2 = new UserMap("John Smith", 2, birthDate1);
        Map<UserMap, Object> map = new HashMap<>();
        map.put(user1, "Value1");
        map.put(user2, "Value2");
        System.out.println(user1);
        System.out.println(user2);
        System.out.println(user1.equals(user2));
        System.out.println(map);
    }
}