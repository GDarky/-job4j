/**
 * 6.2.1. Проиллюстрировать проблемы с многопоточностью.
 *
 * Современные компьютеры зачастую имеют больше одного процессора. И процессоры зачастую имею больше одного ядра
 * При многопоточном программировании, часто бывает ситуация, что несколько потоков выполняются одновременно на разных
 * процессорах или ядрах. Физическое устройство оперативной памяти компьютера таково, что помимо общей оперативной
 * памяти у каждого процессора/ядра существуют регистры и кэш. При выполнении вычислений, данные копируются из
 * основной оперативной памяти в кэш и регистры процессора и обратно. В связи с этим возникают проблемные ситуации,
 * основные из которых:
 *
 *  1. Видимость модификации общих объектов (visibility of shared objects)
 *  2. Состояние гонки (race condition)
 *
 * 1. Если несколько потоков делят объект, то изменения в нем сделанные одним потоком могут быть не видны остальным
 *  потокам. Например, свойство count объекта в оперативной пямяти имеет значение = 1. Первый поток, который работает на
 *  процессоре 1, изменяет значение свойства на 2. Значение свойства меняется на 2 и записывается в кэш процессора 1.
 *  При этом в основной оперативной памяти, значение count всё еще 1. Поток, работающий на процессоре 2,
 *  производит вычисления над тем же свойством count. Для второго потока count = 1,  так как значение еще не изменилось
 *  в основной оперативной памяти.
 *
 * 2. При одновременном выполнении нескольких потоков может возникнуть ситуация, когда результаты работы программы
 * будут разными в зависимости от порядка выполнения потоков. Например, если поток 1 пытается записать в свойство
 * count общего объекта значение 1, а второй поток значение 2, то при каждом запуске программы, результат не определен.
 * Значение count может быть или 1 или 2, в зависимости от того, какой поток выполнился позже.
 */

package dstelmachenko.multithreading;

import javafx.application.Application;
import javafx.scene.Group;
import javafx.scene.Scene;
import javafx.scene.shape.Rectangle;
import javafx.stage.Stage;
import javafx.stage.WindowEvent;

public class PingPong extends Application {
    private static final String JOB4J = "Пинг-понг www.job4j.ru";

    @Override
    public void start(Stage stage) {
        int limitX = 300;
        int limitY = 300;
        Group group = new Group();
        Rectangle rect = new Rectangle(50, 100, 10, 10);
        group.getChildren().add(rect);
        Thread t = new Thread(new RectangleMove(rect));
        t.start();
        stage.setScene(new Scene(group, limitX, limitY));
        stage.setTitle(JOB4J);
        stage.setResizable(false);
        stage.setOnCloseRequest((WindowEvent event) -> {
                    t.interrupt();
                }
        );
        stage.show();
    }
}

